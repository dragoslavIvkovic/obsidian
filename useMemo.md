Јасно — хоћеш дубинско објашњење `useMemo`: „обична“ и напредна употреба, како (и да ли) „чува меморију“, и када може да направи memory leak. Све важи и за React Native.

# Шта `useMemo` ради (у кратко)

- `useMemo(factory, deps)` кешира **резултат функције** (`factory`) док се зависности (`deps`) не промене.
    
- Не „чува меморију“ магично — само **избегава поновно рачунање** и **држи једну референцу** на резултат.
    
- Кеш се баца када се промени нека зависност или се компонента unmount-ује.
    

---

# Обична употреба (правилни основни шаблони)

## 1) Скупо израчунавање (CPU-bound)

```tsx
const filtered = useMemo(() => {
  // скупо: велико филтрирање, сортирање, агрегација…
  return bigList.filter(matchesQuery).sort(byDate);
}, [bigList, query]);
```

Када: операција је приметно скупа и мења се ређе од рендера.

## 2) Стабилни објекти/параметри за зависне ефекте

```tsx
const options = useMemo(() => ({ cache: true, limit }), [limit]);
// избегаваш да useEffect ниже у стаблу „пука“ на сваком ререндеру због новог {}.
```

## 3) Деривисано стање (из више извора)

```tsx
const total = useMemo(() => items.reduce((s, i) => s + i.price, 0), [items]);
```

Када: резултат зависи само од улаза; хоћеш референтну стабилност и перформансе.

---

# Напредна употреба

## A) Мемоизација селектора (попут „reselect“)

Када имаш сложене објекте/листe и компоненте које често ререндерују:

```tsx
function useCartTotals(cart: Cart) {
  return useMemo(() => {
    const subtotal = cart.items.reduce((s,i) => s + i.price*i.qty, 0);
    const tax = Math.round(subtotal * 0.1);
    return { subtotal, tax, total: subtotal + tax };
  }, [cart.items]);
}
```

Циљ: стабилан објекат `{subtotal, tax, total}` да не пале downstream `useEffect`/`memo`.

## B) Стабилизовање пропса ка „мемо“ дечијим компонентама

```tsx
const rowProps = useMemo(() => ({ onPress: handleRowPress, theme }), [handleRowPress, theme]);
// <Row {...rowProps} />  // Row је React.memo
```

Смањује непотребне ререндере великих листи (FlatList item компоненте).

## C) Кеширање трансформисаних података из мрежe

```tsx
const viewModel = useMemo(() => normalize(apiData), [apiData]);
// normalize може бити скуп → мемоизација спречава дупли рад
```

## D) Контрола величине резултата (свесно „одбацивање“)

Ако резултат може бити велики, „сецни“ га у мемо-излазу:

```tsx
const light = useMemo(() => {
  const x = heavyResult(data);
  return { id: x.id, title: x.title }; // не враћај цео x ако не мораш
}, [data]);
```

---

# Када `useMemo` стварно помаже „меморији“

- **Индиректно**: мање рачунања ⇒ мање привремених објеката/алокација ⇒ мање GC притиска.
    
- **Стабилан резултат**: не правиш нови `{}`/`[]`/функцију на сваком ререндеру, па се низводне компоненте/ефекти не активирају → мање посредних алокација.
    

> Важно: `useMemo` **не** компресује/ослобађа меморију сам по себи; само држи _једну_ кеширану вредност.

---

# Када `useMemo` може бити штетан или довести до „memory leak“-а

## 1) Кешираш **огроман резултат** који се ретко/никада не инвалида

- Пример: `useMemo(() => parseHugeJSON(blob), [])`
    
- Ако тај објекат остане у `memo` месецима док је екран жив, држиш велики блок RAM-а.  
    **Решење:** инвалидација зависности кад подаци застаре; или држи лакши view-model.
    

## 2) „Лажеш“ зависности

- Намерно стављаш празан `[]`, иако `factory` зависи од нечег (props/state).
    
- Последица: кеш држи **старе податке** и **референце** на велике структуре (златна карта за цурење).  
    **Решење:** увек наведи _све_ реалне зависности.
    

## 3) Захватање (closure) на **великим** објектима/функцијама које држе ресурсе

- Ако `factory` користи нешто велико из опсега и врати референцу која остаје, може задржати велики граф објеката.  
    **Решење:** унутар `factory` експлицитно издвој/копирај само што ти треба; или очисти извор.
    

## 4) Глобално кеширање унутар `useMemo`

- Чување у неки „static map“/singleton који расте:
    

```tsx
const result = useMemo(() => {
  globalCache.set(key, hugeObj); // никад не бришеш → расте без краја
  return hugeObj;
}, [key]);
```

**Решење:** уведи LRU/лимит/cleanup на unmount или на промени зависности.

## 5) Мемоизација тривијалности

- Мемоизујеш ситнице (нпр. `useMemo(() => a+b, [a,b])`) → трошиш меморију за кеш + трошак компарације deps, без добитка.
    

## 6) Коришћење `useMemo` за **side-effect**

- `useMemo` није `useEffect`. Ако унутра „успут“ креираш listener/контролер/stream без cleanup-а, тај ресурс може процурити.  
    **Решење:** ефекте и ресурсе увек у `useEffect` (са cleanup-ом).
    

---

# Практичне смернице (чек-листа)

1. **Да ли је фабрика скупа?** Ако није, прескочи `useMemo`.
    
2. **Да ли стабилизујеш пропсе за React.memo дете?** Ако да, `useMemo` је OK.
    
3. **Комплетне зависности**: укључи све што фабрика користи.
    
4. **Ограничи величину резултата**: враћај минималан објекат потребан за UI.
    
5. **Животни век**: ако резултат може постати „огроман“, додај механизам да га замениш лакшом верзијом или `null` кад више није потребан.
    
6. **Нема ефеката у `useMemo`**: ресурси (тајмери, слушаоци, AbortController) иду у `useEffect` са cleanup-ом.
    
7. **Измери**: користи профајлер (Flipper/Perf Monitor у RN-у) да провериш да `useMemo` стварно смањује рад/рендере.
    

---

# Мини примери: добро vs. лоше

**Добро — скупо филтрирање:**

```tsx
const visible = useMemo(() => heavyFilter(items, query), [items, query]);
```

**Лоше — празан deps, зависиш од props/state:**

```tsx
// ❌ држи старе податке и меморију
const visible = useMemo(() => heavyFilter(items, query), []);
```

**Добро — стабилан пропс за мемо дете:**

```tsx
const dataProp = useMemo(() => ({ rows }), [rows]);
return <BigList data={dataProp} />; // BigList = React.memo
```

**Лоше — унутра правиш side-effect:**

```tsx
// ❌ никад не чистиш listener
const x = useMemo(() => { Keyboard.addListener('show', onShow); return {}; }, []);
```

---

# `useMemo` vs. `useCallback` vs. `useRef` (брзи избор)

- `useMemo` → кешира **вредност** (објекат/низ/број).
    
- `useCallback` → кешира **функцију** (исти идентитет између рендера).
    
- `useRef` → држи **мутабилну кутију** без ререндера; не рачуна ништа, не пореди deps.
    

Ако треба да стабилизујеш објекат/масив који иде у props/dep → `useMemo`.  
Ако треба стабилан handler → `useCallback`.  
Ако треба интерна мутабилна референца (тајмер/флаг/UI ref) → `useRef`.

---

# TL;DR

- `useMemo` штеди CPU и индиректно RAM (мање привремених алокација), али није „магични чувар меморије“.
    
- Лекови против лејкова: тачне зависности, нема side-effect-а у `useMemo`, не кеширај огромне резултате без стратегије инвалидације/чишћења.
    
- Користи га за скупа израчунавања, стабилне пропсе и деривисане моделе — не за тривијалне ствари.
    

Ако имаш конкретан snippet из RN апликације где сумњаш на leak, пошаљи — показаћу ти где да додаш инвалидацију или cleanup да меморија престане да расте.